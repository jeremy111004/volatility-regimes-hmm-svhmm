# =========================
# Imports
# =========================
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import yfinance as yf
from hmmlearn.hmm import GaussianHMM
from tqdm import tqdm
from sklearn.linear_model import LinearRegression

# =========================
# 1) Data
# =========================
# S&P 500 (change ticker/dates if needed)
data = yf.download('^GSPC', start='2000-01-01', end='2025-04-01')
data['Log_Returns'] = np.log(data['Close'] / data['Close'].shift(1))
data.dropna(inplace=True)
returns = data['Log_Returns'].values.reshape(-1, 1)

# =========================
# 2) Static 3-state HMM
# =========================
# Fit HMM
model = GaussianHMM(n_components=3, covariance_type='full', n_iter=1000, random_state=42)
model.fit(returns)

# Viterbi states
hidden_states = model.predict(returns)

# Reorder states by volatility (low→high)
state_variances = [np.var(returns[hidden_states == i]) for i in range(3)]
sorted_states = np.argsort(state_variances)
remap = {old: new for new, old in enumerate(sorted_states)}
remapped_states = np.vectorize(remap.get)(hidden_states)
data['Hidden_State'] = remapped_states

# =========================
# 3) Regime scatter
# =========================
colors = ['green', 'orange', 'red']  # 0=calm, 2=crisis
plt.figure(figsize=(15, 7))
for i in range(3):
    mask = data['Hidden_State'] == i
    plt.plot(data.index[mask], data['Log_Returns'][mask], '.', label=f"Regime {i}", color=colors[i], alpha=0.6)
plt.title("3-State HMM Regimes on S&P 500")
plt.xlabel("Date")
plt.ylabel("Log Returns")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# =========================
# 4) Regime stats
# =========================
print("Regime stats (sorted by volatility):")
for i in range(3):
    sub = data.loc[data['Hidden_State'] == i, 'Log_Returns']
    print(f"Regime {i}: mean={sub.mean():.5f}, var={sub.var():.5f}")

# =========================
# 5) Implied vol estimate from HMM (per-time covariance)
# =========================
# Note: HMM covariances are state-level; we map the active state's var to each day.
state_var_sequence = np.array([model.covars_[sorted_states == sorted_states[remap[s]]][0][0][0] 
                               if model.covars_.ndim == 3 else model.covars_[remap[s]][0]
                               for s in hidden_states])
data['HMM_Var'] = state_var_sequence
plt.figure(figsize=(14, 5))
plt.plot(data.index, np.sqrt(data['HMM_Var']) * np.sqrt(252))
plt.title("HMM-Implied Volatility (Annualized)")
plt.ylabel("Volatility")
plt.xlabel("Date")
plt.grid(True)
plt.tight_layout()
plt.show()

# =========================
# 6) Vertical color bands by regime (visual context)
# =========================
fig, ax = plt.subplots(figsize=(14, 6))
ax.plot(data.index, data['Log_Returns'], color='black', lw=0.5, label="Log Returns")
color_map = {0: 'green', 1: 'orange', 2: 'red'}
for t, c in zip(data.index, data['Hidden_State'].map(color_map)):
    ax.axvline(t, color=c, alpha=0.01)
ax.set_title("Log Returns with HMM Regimes")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

# =========================
# 7) Average regime duration
# =========================
print("\nAverage duration per regime (days):")
for i in range(3):
    runs = data['Hidden_State'].eq(i).astype(int).groupby((data['Hidden_State'] != i).cumsum()).sum()
    print(f"Regime {i}: {runs.mean():.2f}")

# =========================
# 8) Transition matrix (sorted)
# =========================
trans_mat_sorted = model.transmat_[sorted_states, :][:, sorted_states]
trans_df = pd.DataFrame(trans_mat_sorted, columns=[f'Regime {i}' for i in range(3)],
                        index=[f'Regime {i}' for i in range(3)])
plt.figure(figsize=(4, 3))
sns.heatmap(trans_df, annot=True, cmap='Blues', fmt=".2f")
plt.title("HMM Transition Matrix (sorted)")
plt.tight_layout()
plt.show()

# =========================
# 9) One-step ahead regime probabilities
# =========================
last_state = hidden_states[-1]
proba_next = model.transmat_[last_state]
print("\nOne-step regime forecast:")
for i, p in enumerate(proba_next):
    print(f"→ P(Regime {i} tomorrow): {p:.2%}")

regime_forecast = int(np.argmax(proba_next))
print(f"\nMost likely tomorrow: Regime {regime_forecast}")

plt.figure(figsize=(6, 4))
sns.barplot(x=[f"Regime {i}" for i in range(3)], y=proba_next, palette=colors)
plt.title("Tomorrow's Regime Probabilities")
plt.ylim(0, 1)
plt.ylabel("Probability")
plt.grid(True, axis='y')
plt.tight_layout()
plt.show()

# =========================
# 10) Strategy 1: long if next-regime=0 (state-0 long)
# =========================
pred_next = [np.nan]
for t in range(len(hidden_states) - 1):
    s = hidden_states[t]
    pred_next.append(np.argmax(model.transmat_[s]))
data['Predicted_Regime'] = pred_next

data['Strat_Ret_S0'] = data['Log_Returns'] * (data['Predicted_Regime'] == 0)
data['Cum_Strat_S0'] = (1 + data['Strat_Ret_S0']).cumprod()
data['Cum_Market'] = (1 + data['Log_Returns']).cumprod()

plt.figure(figsize=(14, 6))
plt.plot(data.index, data['Cum_Market'], label='Buy & Hold', color='black', linestyle='--')
plt.plot(data.index, data['Cum_Strat_S0'], label='HMM Strategy (long if state 0)', color='green')
plt.title("Cumulative Performance: HMM (state-0) vs Buy & Hold")
plt.ylabel("Wealth (base=1)")
plt.xlabel("Date")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

perf = data[['Strat_Ret_S0', 'Log_Returns']].dropna()
ann_mu_s0 = perf['Strat_Ret_S0'].mean() * 252
ann_vol_s0 = perf['Strat_Ret_S0'].std() * np.sqrt(252)
ann_mu_mkt = perf['Log_Returns'].mean() * 252
ann_vol_mkt = perf['Log_Returns'].std() * np.sqrt(252)
print("Annualized performance (state-0 strategy):")
print(f"Strategy: Return={ann_mu_s0:.2%}, Vol={ann_vol_s0:.2%}, Sharpe={ann_mu_s0/ann_vol_s0:.2f}")
print(f"Market  : Return={ann_mu_mkt:.2%}, Vol={ann_vol_mkt:.2%}, Sharpe={ann_mu_mkt/ann_vol_mkt:.2f}")

# =========================
# 11) Strategy 2: multi-regime (+1, 0, −1)
# =========================
pos_map = {0: 1, 1: 0, 2: -1}
data['Position_Multi'] = data['Predicted_Regime'].map(pos_map)
data['Strat_Ret_Multi'] = data['Log_Returns'] * data['Position_Multi']
data['Cum_Strat_Multi'] = (1 + data['Strat_Ret_Multi']).cumprod()
data['Cum_BH'] = (1 + data['Log_Returns']).cumprod()

plt.figure(figsize=(14, 6))
plt.plot(data.index, data['Cum_BH'], label='Buy & Hold', linestyle='--', color='gray')
plt.plot(data.index, data['Cum_Strat_Multi'], label='HMM Multi-Regime', color='purple')
plt.title("Cumulative Performance: HMM Multi-Regime vs Buy & Hold")
plt.ylabel("Wealth (base=1)")
plt.xlabel("Date")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

perf2 = data[['Strat_Ret_Multi', 'Log_Returns']].dropna()
ann_mu_multi = perf2['Strat_Ret_Multi'].mean() * 252
ann_vol_multi = perf2['Strat_Ret_Multi'].std() * np.sqrt(252)
ann_mu_bh = perf2['Log_Returns'].mean() * 252
ann_vol_bh = perf2['Log_Returns'].std() * np.sqrt(252)
print("\nAnnualized performance (multi-regime):")
print(f"Multi : Return={ann_mu_multi:.2%}, Vol={ann_vol_multi:.2%}, Sharpe={ann_mu_multi/ann_vol_multi:.2f}")
print(f"Buy&H : Return={ann_mu_bh:.2%}, Vol={ann_vol_bh:.2%}, Sharpe={ann_mu_bh/ann_vol_bh:.2f}")

# =========================
# 12) Model order check (AIC/BIC across K)
# =========================
K_range = range(1, 6)
loglikes, aics, bics = [], [], []
n_obs = len(returns)

for k in K_range:
    try:
        m = GaussianHMM(n_components=k, covariance_type='full', n_iter=1000, random_state=42)
        m.fit(returns)
        ll = m.score(returns)
        # parameter count (approx, for univariate returns)
        n_params = (k - 1) + (k * (k - 1)) + k + k  # startprob + transmat + var + mean
        aic = -2 * ll + 2 * n_params
        bic = -2 * ll + n_params * np.log(n_obs)
    except Exception as e:
        ll, aic, bic = np.nan, np.nan, np.nan
    loglikes.append(ll); aics.append(aic); bics.append(bic)

fig, ax = plt.subplots(2, 1, figsize=(10, 10), sharex=True)
ax[0].plot(K_range, loglikes, marker='o')
ax[0].set_title("Log-Likelihood vs #States"); ax[0].set_ylabel("Log-L")
ax[0].grid(True)
ax[1].plot(K_range, aics, marker='s', label='AIC')
ax[1].plot(K_range, bics, marker='^', label='BIC')
ax[1].set_title("AIC / BIC vs #States"); ax[1].set_xlabel("#States"); ax[1].set_ylabel("Score")
ax[1].legend(); ax[1].grid(True)
plt.tight_layout(); plt.show()

best_k_bic = K_range[int(np.nanargmin(bics))]
print(f"\nBIC-optimal number of states: {best_k_bic}")

# =========================
# 13) Rolling HMM (semi-sequential) with simple Panic Mode (4 states)
# =========================
rolling_window = 500
refit_every = 5
positions, dates, ret_strat, panic_flags = [], [], [], []

model_roll = None
last_transmat = None
last_state = None
n_states = 4

panic_mode = False
panic_timer = 0

for t in tqdm(range(rolling_window, len(data) - 1), desc="Rolling HMM 4-state + Panic"):
    window_ret = returns[t - rolling_window:t]

    if (t - rolling_window) % refit_every == 0:
        try:
            if np.var(window_ret) < 1e-7:
                continue
            model_roll = GaussianHMM(n_components=n_states, covariance_type='full', n_iter=300, random_state=42)
            model_roll.fit(window_ret)
            viterbi = model_roll.predict(window_ret)
            vols = [np.var(window_ret[viterbi == i]) for i in range(n_states)]
            order = np.argsort(vols)
            last_state = order.tolist().index(viterbi[-1])
            last_transmat = model_roll.transmat_[order][:, order]
        except:
            continue

    if model_roll is None or last_transmat is None:
        continue

    # simple risk trigger
    rolling_vol = np.std(returns[t - 20:t]) * np.sqrt(252)
    recent_ret = np.mean(returns[t - 5:t])

    if not panic_mode and (rolling_vol > 0.6 and recent_ret < -0.01):
        panic_mode = True; panic_timer = 30
    elif panic_mode:
        if (rolling_vol < 0.3 and recent_ret > 0) or panic_timer <= 0:
            panic_mode = False
        else:
            panic_timer -= 1

    if panic_mode:
        pos = 0.0
        panic_flags.append(1)
    else:
        p_next = last_transmat[last_state]
        pos = p_next[0]*1 + p_next[1]*0.5 + p_next[2]*(-0.5) + p_next[3]*(-1)
        last_state = int(np.argmax(p_next))
        panic_flags.append(0)

    r_next = data['Log_Returns'].iloc[t + 1]
    positions.append(pos); dates.append(data.index[t + 1]); ret_strat.append(pos * r_next)

df_roll = pd.DataFrame({'Date': dates, 'Position': positions,
                        'Return_Strategy': ret_strat, 'Panic': panic_flags}).set_index('Date')
df_roll['Cum_Strategy'] = (1 + df_roll['Return_Strategy']).cumprod()
df_roll['Cum_Market'] = (1 + data['Log_Returns'].loc[df_roll.index]).cumprod()

plt.figure(figsize=(14, 6))
plt.plot(df_roll.index, df_roll['Cum_Market'], '--', color='gray', label='Buy & Hold')
plt.plot(df_roll.index, df_roll['Cum_Strategy'], color='darkred', label='HMM (4-state) + Panic')
for d, f in zip(df_roll.index, df_roll['Panic']):
    if f == 1:
        plt.axvline(d, color='red', alpha=0.02)
plt.title("Rolling HMM (4 states) with Panic Mode")
plt.ylabel("Wealth (base=1)")
plt.grid(True); plt.legend(); plt.tight_layout(); plt.show()

ann_mu = df_roll['Return_Strategy'].mean() * 252
ann_vol = df_roll['Return_Strategy'].std() * np.sqrt(252)
print("\nRolling HMM (4-state) + Panic — Annualized:")
print(f"Return={ann_mu:.2%}  Vol={ann_vol:.2%}  Sharpe={ann_mu/ann_vol if ann_vol>0 else np.nan:.2f}")

# =========================
# 14) MA100 benchmark (BTC example)
# =========================
btc = yf.download('BTC-USD', start='2014-01-01', end='2025-01-01')
btc['Log_Returns'] = np.log(btc['Close'] / btc['Close'].shift(1))
btc['MA100'] = btc['Close'].rolling(100).mean()
btc.dropna(inplace=True)

pos, dates_b, ret = [], [], []
for t in range(len(btc) - 1):
    position = 1 if float(btc['Close'].iloc[t]) > float(btc['MA100'].iloc[t]) else -1
    r_next = btc['Log_Returns'].iloc[t + 1]
    pos.append(position); dates_b.append(btc.index[t + 1]); ret.append(position * r_next)

df_ma = pd.DataFrame({'Date': dates_b, 'Position': pos, 'Return_Strategy': ret}).set_index('Date')
df_ma['Cum_Strategy'] = (1 + df_ma['Return_Strategy']).cumprod()
df_ma['Cum_Market'] = (1 + btc['Log_Returns'].loc[df_ma.index]).cumprod()

plt.figure(figsize=(14, 6))
plt.plot(df_ma.index, df_ma['Cum_Market'], '--', label='Buy & Hold', color='gray')
plt.plot(df_ma.index, df_ma['Cum_Strategy'], label='MA100 Strategy', color='red')
plt.title("BTC: Buy & Hold vs MA100 Strategy")
plt.ylabel("Wealth (base=1)")
plt.grid(True); plt.legend(); plt.tight_layout(); plt.show()

mu = df_ma['Return_Strategy'].mean() * 252
sig = df_ma['Return_Strategy'].std() * np.sqrt(252)
print("MA100 Strategy (BTC):")
print(f"Return={mu:.2%}  Vol={sig:.2%}  Sharpe={mu/sig if sig>0 else np.nan:.2f}")

# =========================
# 15) SV-HMM style (static) — AR(1) on log(R^2) per regime
# =========================
# Reuse earlier 3-state static regimes
data['Log_R2'] = np.log(data['Log_Returns']**2 + 1e-8)
params = {}
h_t = np.zeros(len(data))
for s in range(3):
    idx = data['Hidden_State'] == s
    y = data.loc[idx, 'Log_R2'].values
    if len(y) < 3:
        continue
    x_lag = np.roll(y, 1)[1:]; y_fit = y[1:]
    ar = LinearRegression().fit(x_lag.reshape(-1, 1), y_fit)
    phi = ar.coef_[0]
    mu = ar.intercept_/(1 - phi) if abs(phi) < 1 else np.mean(y)
    params[s] = {'phi': phi, 'mu': mu}

    indices = np.where(idx)[0]
    if len(indices) > 0:
        h_t[indices[0]] = mu
        for i in range(1, len(indices)):
            t0 = indices[i]; t_prev = indices[i - 1]
            h_t[t0] = mu + phi * (h_t[t_prev] - mu) if t0 == t_prev + 1 else mu

data['SV_h'] = h_t
data['SV_Sigma'] = np.exp(h_t / 2)

plt.figure(figsize=(14, 5))
plt.plot(data.index, data['SV_Sigma'] * np.sqrt(252), label='SV-HMM (annualized)')
plt.title("SV-HMM-style Implied Volatility (AR(1) per regime)")
plt.xlabel("Date"); plt.ylabel("Volatility")
plt.grid(True); plt.legend(); plt.tight_layout(); plt.show()

# Simple tri-state trading rule using regimes (same as multi-regime earlier)
# Already computed above; you can reuse Position_Multi or design a vol-scaled variant.

# =========================
# 16) SV-HMM (rolling, with trend & vol scaling) — Example on AAPL
# =========================
rng = np.random.default_rng(42)
jitter_scale = 1e-8

aapl = yf.download('AAPL', start='2004-01-01', end='2025-01-01')
aapl['Log_Returns'] = np.log(aapl['Close'] / aapl['Close'].shift(1))
aapl['MA100']       = aapl['Close'].shift(1).rolling(100).mean()
aapl.dropna(inplace=True)
lr = aapl['Log_Returns'].values

window = 300
refit_every = 10
tc = 0.001  # simple cost proxy

pos, dts, pnl, reg = [], [], [], []
cur_sig = 0.0; cur_reg = 1; cur_sigma = 0.0

for t in tqdm(range(window, len(aapl) - 1), desc="Rolling SV-HMM (AAPL)"):
    if (t - window) % refit_every == 0:
        wr = lr[t - window:t].reshape(-1, 1)
        if np.var(wr) >= 1e-8:
            try:
                wrj = wr + rng.normal(0, jitter_scale, wr.shape)
                m = GaussianHMM(n_components=3, covariance_type='full', n_iter=300, random_state=42)
                m.fit(wrj)
                proba = m.predict_proba(wrj)
                last_p = proba[-1]
                vols = [np.trace(c) for c in m.covars_]
                ord3 = np.argsort(vols)
                p_ord = np.array([last_p[i] for i in ord3])

                # AR(1) on log-sq-returns for per-state sigma forecast
                lr2 = np.log(wrj.flatten()**2 + 1e-8)
                sigma_states = np.zeros(3)
                for i in range(3):
                    idx = np.where(proba[:, i] > 0.5)[0]
                    if len(idx) >= 5:
                        y  = lr2[idx]
                        x  = y[:-1]; y1 = y[1:]
                        ar = LinearRegression().fit(x.reshape(-1, 1), y1)
                        phi = ar.coef_[0]
                        if abs(phi) < 1:
                            mu = ar.intercept_/(1 - phi)
                            h  = mu + phi*(y1[-1] - mu)
                            sigma_states[i] = np.exp(h/2)
                        else:
                            sigma_states[i] = np.nan
                    else:
                        sigma_states[i] = np.nan

                vmask = ~np.isnan(sigma_states)
                if vmask.any():
                    cur_sigma = (p_ord[vmask] * sigma_states[vmask]).sum() / p_ord[vmask].sum()

                # trend filter
                price = float(aapl['Close'].iloc[t]); ma100 = float(aapl['MA100'].iloc[t])
                lw, sw = (2.0, -0.25) if price > ma100 else (0.75, -1.0)

                hmm_sig = p_ord[0]*lw + p_ord[2]*sw
                cur_sig = 0.5*hmm_sig if cur_sigma > 0.03 else hmm_sig
                cur_reg = int(np.argmax(p_ord))
            except Exception as e:
                # keep previous signal if refit fails
                pass

    r_next = lr[t + 1]
    cost = tc * abs(cur_sig - (pos[-1] if pos else 0.0))
    pnl_day = cur_sig * r_next - cost

    pos.append(cur_sig); pnl.append(pnl_day); reg.append(cur_reg); dts.append(aapl.index[t + 1])

df_sv = pd.DataFrame({'Date': dts, 'Position': pos, 'Return_Strategy': pnl, 'Regime': reg}).set_index('Date')
df_sv['Cum_Strategy'] = (1 + df_sv['Return_Strategy']).cumprod()
df_sv['Cum_Market']   = (1 + aapl['Log_Returns'].loc[df_sv.index]).cumprod()

plt.figure(figsize=(12, 6))
plt.plot(df_sv.index, df_sv['Cum_Market'], '--', label='Buy & Hold')
plt.plot(df_sv.index, df_sv['Cum_Strategy'], label='SV-HMM Strategy')
plt.legend(); plt.title("SV-HMM Strategy vs Buy & Hold (AAPL)")
plt.grid(True); plt.tight_layout(); plt.show()

mu = df_sv['Return_Strategy'].mean() * 252
vol = df_sv['Return_Strategy'].std() * np.sqrt(252)
print("SV-HMM (rolling) — Annualized:")
print(f"Return={mu:.2%}  Vol={vol:.2%}  Sharpe={mu/vol if vol>0 else np.nan:.2f}")
